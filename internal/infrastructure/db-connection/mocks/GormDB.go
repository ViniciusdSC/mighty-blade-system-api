// Code generated by mockery v2.36.0. DO NOT EDIT.

package dbconnection

import (
	context "context"

	clause "gorm.io/gorm/clause"

	gorm "gorm.io/gorm"

	mock "github.com/stretchr/testify/mock"

	sql "database/sql"
)

// MockGormDB is an autogenerated mock type for the GormDB type
type MockGormDB struct {
	mock.Mock
}

type MockGormDB_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGormDB) EXPECT() *MockGormDB_Expecter {
	return &MockGormDB_Expecter{mock: &_m.Mock}
}

// AddError provides a mock function with given fields: err
func (_m *MockGormDB) AddError(err error) error {
	ret := _m.Called(err)

	var r0 error
	if rf, ok := ret.Get(0).(func(error) error); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGormDB_AddError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddError'
type MockGormDB_AddError_Call struct {
	*mock.Call
}

// AddError is a helper method to define mock.On call
//   - err error
func (_e *MockGormDB_Expecter) AddError(err interface{}) *MockGormDB_AddError_Call {
	return &MockGormDB_AddError_Call{Call: _e.mock.On("AddError", err)}
}

func (_c *MockGormDB_AddError_Call) Run(run func(err error)) *MockGormDB_AddError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockGormDB_AddError_Call) Return(_a0 error) *MockGormDB_AddError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_AddError_Call) RunAndReturn(run func(error) error) *MockGormDB_AddError_Call {
	_c.Call.Return(run)
	return _c
}

// Assign provides a mock function with given fields: attrs
func (_m *MockGormDB) Assign(attrs ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, attrs...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...interface{}) *gorm.DB); ok {
		r0 = rf(attrs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Assign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Assign'
type MockGormDB_Assign_Call struct {
	*mock.Call
}

// Assign is a helper method to define mock.On call
//   - attrs ...interface{}
func (_e *MockGormDB_Expecter) Assign(attrs ...interface{}) *MockGormDB_Assign_Call {
	return &MockGormDB_Assign_Call{Call: _e.mock.On("Assign",
		append([]interface{}{}, attrs...)...)}
}

func (_c *MockGormDB_Assign_Call) Run(run func(attrs ...interface{})) *MockGormDB_Assign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Assign_Call) Return(tx *gorm.DB) *MockGormDB_Assign_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Assign_Call) RunAndReturn(run func(...interface{}) *gorm.DB) *MockGormDB_Assign_Call {
	_c.Call.Return(run)
	return _c
}

// Association provides a mock function with given fields: column
func (_m *MockGormDB) Association(column string) *gorm.Association {
	ret := _m.Called(column)

	var r0 *gorm.Association
	if rf, ok := ret.Get(0).(func(string) *gorm.Association); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.Association)
		}
	}

	return r0
}

// MockGormDB_Association_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Association'
type MockGormDB_Association_Call struct {
	*mock.Call
}

// Association is a helper method to define mock.On call
//   - column string
func (_e *MockGormDB_Expecter) Association(column interface{}) *MockGormDB_Association_Call {
	return &MockGormDB_Association_Call{Call: _e.mock.On("Association", column)}
}

func (_c *MockGormDB_Association_Call) Run(run func(column string)) *MockGormDB_Association_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGormDB_Association_Call) Return(_a0 *gorm.Association) *MockGormDB_Association_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Association_Call) RunAndReturn(run func(string) *gorm.Association) *MockGormDB_Association_Call {
	_c.Call.Return(run)
	return _c
}

// Attrs provides a mock function with given fields: attrs
func (_m *MockGormDB) Attrs(attrs ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, attrs...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...interface{}) *gorm.DB); ok {
		r0 = rf(attrs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Attrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Attrs'
type MockGormDB_Attrs_Call struct {
	*mock.Call
}

// Attrs is a helper method to define mock.On call
//   - attrs ...interface{}
func (_e *MockGormDB_Expecter) Attrs(attrs ...interface{}) *MockGormDB_Attrs_Call {
	return &MockGormDB_Attrs_Call{Call: _e.mock.On("Attrs",
		append([]interface{}{}, attrs...)...)}
}

func (_c *MockGormDB_Attrs_Call) Run(run func(attrs ...interface{})) *MockGormDB_Attrs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Attrs_Call) Return(tx *gorm.DB) *MockGormDB_Attrs_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Attrs_Call) RunAndReturn(run func(...interface{}) *gorm.DB) *MockGormDB_Attrs_Call {
	_c.Call.Return(run)
	return _c
}

// AutoMigrate provides a mock function with given fields: dst
func (_m *MockGormDB) AutoMigrate(dst ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dst...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...interface{}) error); ok {
		r0 = rf(dst...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGormDB_AutoMigrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AutoMigrate'
type MockGormDB_AutoMigrate_Call struct {
	*mock.Call
}

// AutoMigrate is a helper method to define mock.On call
//   - dst ...interface{}
func (_e *MockGormDB_Expecter) AutoMigrate(dst ...interface{}) *MockGormDB_AutoMigrate_Call {
	return &MockGormDB_AutoMigrate_Call{Call: _e.mock.On("AutoMigrate",
		append([]interface{}{}, dst...)...)}
}

func (_c *MockGormDB_AutoMigrate_Call) Run(run func(dst ...interface{})) *MockGormDB_AutoMigrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_AutoMigrate_Call) Return(_a0 error) *MockGormDB_AutoMigrate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_AutoMigrate_Call) RunAndReturn(run func(...interface{}) error) *MockGormDB_AutoMigrate_Call {
	_c.Call.Return(run)
	return _c
}

// Begin provides a mock function with given fields: opts
func (_m *MockGormDB) Begin(opts ...*sql.TxOptions) *gorm.DB {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...*sql.TxOptions) *gorm.DB); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Begin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Begin'
type MockGormDB_Begin_Call struct {
	*mock.Call
}

// Begin is a helper method to define mock.On call
//   - opts ...*sql.TxOptions
func (_e *MockGormDB_Expecter) Begin(opts ...interface{}) *MockGormDB_Begin_Call {
	return &MockGormDB_Begin_Call{Call: _e.mock.On("Begin",
		append([]interface{}{}, opts...)...)}
}

func (_c *MockGormDB_Begin_Call) Run(run func(opts ...*sql.TxOptions)) *MockGormDB_Begin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*sql.TxOptions, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(*sql.TxOptions)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Begin_Call) Return(_a0 *gorm.DB) *MockGormDB_Begin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Begin_Call) RunAndReturn(run func(...*sql.TxOptions) *gorm.DB) *MockGormDB_Begin_Call {
	_c.Call.Return(run)
	return _c
}

// Clauses provides a mock function with given fields: conds
func (_m *MockGormDB) Clauses(conds ...clause.Expression) *gorm.DB {
	_va := make([]interface{}, len(conds))
	for _i := range conds {
		_va[_i] = conds[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...clause.Expression) *gorm.DB); ok {
		r0 = rf(conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Clauses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Clauses'
type MockGormDB_Clauses_Call struct {
	*mock.Call
}

// Clauses is a helper method to define mock.On call
//   - conds ...clause.Expression
func (_e *MockGormDB_Expecter) Clauses(conds ...interface{}) *MockGormDB_Clauses_Call {
	return &MockGormDB_Clauses_Call{Call: _e.mock.On("Clauses",
		append([]interface{}{}, conds...)...)}
}

func (_c *MockGormDB_Clauses_Call) Run(run func(conds ...clause.Expression)) *MockGormDB_Clauses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]clause.Expression, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(clause.Expression)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Clauses_Call) Return(tx *gorm.DB) *MockGormDB_Clauses_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Clauses_Call) RunAndReturn(run func(...clause.Expression) *gorm.DB) *MockGormDB_Clauses_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields:
func (_m *MockGormDB) Commit() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type MockGormDB_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *MockGormDB_Expecter) Commit() *MockGormDB_Commit_Call {
	return &MockGormDB_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *MockGormDB_Commit_Call) Run(run func()) *MockGormDB_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGormDB_Commit_Call) Return(_a0 *gorm.DB) *MockGormDB_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Commit_Call) RunAndReturn(run func() *gorm.DB) *MockGormDB_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// Connection provides a mock function with given fields: fc
func (_m *MockGormDB) Connection(fc func(*gorm.DB) error) error {
	ret := _m.Called(fc)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*gorm.DB) error) error); ok {
		r0 = rf(fc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGormDB_Connection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connection'
type MockGormDB_Connection_Call struct {
	*mock.Call
}

// Connection is a helper method to define mock.On call
//   - fc func(*gorm.DB) error
func (_e *MockGormDB_Expecter) Connection(fc interface{}) *MockGormDB_Connection_Call {
	return &MockGormDB_Connection_Call{Call: _e.mock.On("Connection", fc)}
}

func (_c *MockGormDB_Connection_Call) Run(run func(fc func(*gorm.DB) error)) *MockGormDB_Connection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(*gorm.DB) error))
	})
	return _c
}

func (_c *MockGormDB_Connection_Call) Return(err error) *MockGormDB_Connection_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockGormDB_Connection_Call) RunAndReturn(run func(func(*gorm.DB) error) error) *MockGormDB_Connection_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with given fields: count
func (_m *MockGormDB) Count(count *int64) *gorm.DB {
	ret := _m.Called(count)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(*int64) *gorm.DB); ok {
		r0 = rf(count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockGormDB_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - count *int64
func (_e *MockGormDB_Expecter) Count(count interface{}) *MockGormDB_Count_Call {
	return &MockGormDB_Count_Call{Call: _e.mock.On("Count", count)}
}

func (_c *MockGormDB_Count_Call) Run(run func(count *int64)) *MockGormDB_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*int64))
	})
	return _c
}

func (_c *MockGormDB_Count_Call) Return(tx *gorm.DB) *MockGormDB_Count_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Count_Call) RunAndReturn(run func(*int64) *gorm.DB) *MockGormDB_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: value
func (_m *MockGormDB) Create(value interface{}) *gorm.DB {
	ret := _m.Called(value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockGormDB_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - value interface{}
func (_e *MockGormDB_Expecter) Create(value interface{}) *MockGormDB_Create_Call {
	return &MockGormDB_Create_Call{Call: _e.mock.On("Create", value)}
}

func (_c *MockGormDB_Create_Call) Run(run func(value interface{})) *MockGormDB_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Create_Call) Return(tx *gorm.DB) *MockGormDB_Create_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Create_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MockGormDB_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateInBatches provides a mock function with given fields: value, batchSize
func (_m *MockGormDB) CreateInBatches(value interface{}, batchSize int) *gorm.DB {
	ret := _m.Called(value, batchSize)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, int) *gorm.DB); ok {
		r0 = rf(value, batchSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_CreateInBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateInBatches'
type MockGormDB_CreateInBatches_Call struct {
	*mock.Call
}

// CreateInBatches is a helper method to define mock.On call
//   - value interface{}
//   - batchSize int
func (_e *MockGormDB_Expecter) CreateInBatches(value interface{}, batchSize interface{}) *MockGormDB_CreateInBatches_Call {
	return &MockGormDB_CreateInBatches_Call{Call: _e.mock.On("CreateInBatches", value, batchSize)}
}

func (_c *MockGormDB_CreateInBatches_Call) Run(run func(value interface{}, batchSize int)) *MockGormDB_CreateInBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(int))
	})
	return _c
}

func (_c *MockGormDB_CreateInBatches_Call) Return(tx *gorm.DB) *MockGormDB_CreateInBatches_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_CreateInBatches_Call) RunAndReturn(run func(interface{}, int) *gorm.DB) *MockGormDB_CreateInBatches_Call {
	_c.Call.Return(run)
	return _c
}

// DB provides a mock function with given fields:
func (_m *MockGormDB) DB() (*sql.DB, error) {
	ret := _m.Called()

	var r0 *sql.DB
	var r1 error
	if rf, ok := ret.Get(0).(func() (*sql.DB, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *sql.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.DB)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGormDB_DB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DB'
type MockGormDB_DB_Call struct {
	*mock.Call
}

// DB is a helper method to define mock.On call
func (_e *MockGormDB_Expecter) DB() *MockGormDB_DB_Call {
	return &MockGormDB_DB_Call{Call: _e.mock.On("DB")}
}

func (_c *MockGormDB_DB_Call) Run(run func()) *MockGormDB_DB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGormDB_DB_Call) Return(_a0 *sql.DB, _a1 error) *MockGormDB_DB_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGormDB_DB_Call) RunAndReturn(run func() (*sql.DB, error)) *MockGormDB_DB_Call {
	_c.Call.Return(run)
	return _c
}

// Debug provides a mock function with given fields:
func (_m *MockGormDB) Debug() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Debug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Debug'
type MockGormDB_Debug_Call struct {
	*mock.Call
}

// Debug is a helper method to define mock.On call
func (_e *MockGormDB_Expecter) Debug() *MockGormDB_Debug_Call {
	return &MockGormDB_Debug_Call{Call: _e.mock.On("Debug")}
}

func (_c *MockGormDB_Debug_Call) Run(run func()) *MockGormDB_Debug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGormDB_Debug_Call) Return(tx *gorm.DB) *MockGormDB_Debug_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Debug_Call) RunAndReturn(run func() *gorm.DB) *MockGormDB_Debug_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: value, conds
func (_m *MockGormDB) Delete(value interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(value, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockGormDB_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - value interface{}
//   - conds ...interface{}
func (_e *MockGormDB_Expecter) Delete(value interface{}, conds ...interface{}) *MockGormDB_Delete_Call {
	return &MockGormDB_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{value}, conds...)...)}
}

func (_c *MockGormDB_Delete_Call) Run(run func(value interface{}, conds ...interface{})) *MockGormDB_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Delete_Call) Return(tx *gorm.DB) *MockGormDB_Delete_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Delete_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Distinct provides a mock function with given fields: args
func (_m *MockGormDB) Distinct(args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...interface{}) *gorm.DB); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Distinct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Distinct'
type MockGormDB_Distinct_Call struct {
	*mock.Call
}

// Distinct is a helper method to define mock.On call
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Distinct(args ...interface{}) *MockGormDB_Distinct_Call {
	return &MockGormDB_Distinct_Call{Call: _e.mock.On("Distinct",
		append([]interface{}{}, args...)...)}
}

func (_c *MockGormDB_Distinct_Call) Run(run func(args ...interface{})) *MockGormDB_Distinct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Distinct_Call) Return(tx *gorm.DB) *MockGormDB_Distinct_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Distinct_Call) RunAndReturn(run func(...interface{}) *gorm.DB) *MockGormDB_Distinct_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: _a0, values
func (_m *MockGormDB) Exec(_a0 string, values ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *gorm.DB); ok {
		r0 = rf(_a0, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockGormDB_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - _a0 string
//   - values ...interface{}
func (_e *MockGormDB_Expecter) Exec(_a0 interface{}, values ...interface{}) *MockGormDB_Exec_Call {
	return &MockGormDB_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{_a0}, values...)...)}
}

func (_c *MockGormDB_Exec_Call) Run(run func(_a0 string, values ...interface{})) *MockGormDB_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Exec_Call) Return(tx *gorm.DB) *MockGormDB_Exec_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Exec_Call) RunAndReturn(run func(string, ...interface{}) *gorm.DB) *MockGormDB_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: dest, conds
func (_m *MockGormDB) Find(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type MockGormDB_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MockGormDB_Expecter) Find(dest interface{}, conds ...interface{}) *MockGormDB_Find_Call {
	return &MockGormDB_Find_Call{Call: _e.mock.On("Find",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MockGormDB_Find_Call) Run(run func(dest interface{}, conds ...interface{})) *MockGormDB_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Find_Call) Return(tx *gorm.DB) *MockGormDB_Find_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Find_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindInBatches provides a mock function with given fields: dest, batchSize, fc
func (_m *MockGormDB) FindInBatches(dest interface{}, batchSize int, fc func(*gorm.DB, int) error) *gorm.DB {
	ret := _m.Called(dest, batchSize, fc)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, int, func(*gorm.DB, int) error) *gorm.DB); ok {
		r0 = rf(dest, batchSize, fc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_FindInBatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindInBatches'
type MockGormDB_FindInBatches_Call struct {
	*mock.Call
}

// FindInBatches is a helper method to define mock.On call
//   - dest interface{}
//   - batchSize int
//   - fc func(*gorm.DB , int) error
func (_e *MockGormDB_Expecter) FindInBatches(dest interface{}, batchSize interface{}, fc interface{}) *MockGormDB_FindInBatches_Call {
	return &MockGormDB_FindInBatches_Call{Call: _e.mock.On("FindInBatches", dest, batchSize, fc)}
}

func (_c *MockGormDB_FindInBatches_Call) Run(run func(dest interface{}, batchSize int, fc func(*gorm.DB, int) error)) *MockGormDB_FindInBatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(int), args[2].(func(*gorm.DB, int) error))
	})
	return _c
}

func (_c *MockGormDB_FindInBatches_Call) Return(_a0 *gorm.DB) *MockGormDB_FindInBatches_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_FindInBatches_Call) RunAndReturn(run func(interface{}, int, func(*gorm.DB, int) error) *gorm.DB) *MockGormDB_FindInBatches_Call {
	_c.Call.Return(run)
	return _c
}

// First provides a mock function with given fields: dest, conds
func (_m *MockGormDB) First(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_First_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'First'
type MockGormDB_First_Call struct {
	*mock.Call
}

// First is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MockGormDB_Expecter) First(dest interface{}, conds ...interface{}) *MockGormDB_First_Call {
	return &MockGormDB_First_Call{Call: _e.mock.On("First",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MockGormDB_First_Call) Run(run func(dest interface{}, conds ...interface{})) *MockGormDB_First_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_First_Call) Return(tx *gorm.DB) *MockGormDB_First_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_First_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_First_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrCreate provides a mock function with given fields: dest, conds
func (_m *MockGormDB) FirstOrCreate(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_FirstOrCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrCreate'
type MockGormDB_FirstOrCreate_Call struct {
	*mock.Call
}

// FirstOrCreate is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MockGormDB_Expecter) FirstOrCreate(dest interface{}, conds ...interface{}) *MockGormDB_FirstOrCreate_Call {
	return &MockGormDB_FirstOrCreate_Call{Call: _e.mock.On("FirstOrCreate",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MockGormDB_FirstOrCreate_Call) Run(run func(dest interface{}, conds ...interface{})) *MockGormDB_FirstOrCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_FirstOrCreate_Call) Return(tx *gorm.DB) *MockGormDB_FirstOrCreate_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_FirstOrCreate_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_FirstOrCreate_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrInit provides a mock function with given fields: dest, conds
func (_m *MockGormDB) FirstOrInit(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_FirstOrInit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrInit'
type MockGormDB_FirstOrInit_Call struct {
	*mock.Call
}

// FirstOrInit is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MockGormDB_Expecter) FirstOrInit(dest interface{}, conds ...interface{}) *MockGormDB_FirstOrInit_Call {
	return &MockGormDB_FirstOrInit_Call{Call: _e.mock.On("FirstOrInit",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MockGormDB_FirstOrInit_Call) Run(run func(dest interface{}, conds ...interface{})) *MockGormDB_FirstOrInit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_FirstOrInit_Call) Return(tx *gorm.DB) *MockGormDB_FirstOrInit_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_FirstOrInit_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_FirstOrInit_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: key
func (_m *MockGormDB) Get(key string) (interface{}, bool) {
	ret := _m.Called(key)

	var r0 interface{}
	var r1 bool
	if rf, ok := ret.Get(0).(func(string) (interface{}, bool)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) interface{}); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MockGormDB_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockGormDB_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - key string
func (_e *MockGormDB_Expecter) Get(key interface{}) *MockGormDB_Get_Call {
	return &MockGormDB_Get_Call{Call: _e.mock.On("Get", key)}
}

func (_c *MockGormDB_Get_Call) Run(run func(key string)) *MockGormDB_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGormDB_Get_Call) Return(_a0 interface{}, _a1 bool) *MockGormDB_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGormDB_Get_Call) RunAndReturn(run func(string) (interface{}, bool)) *MockGormDB_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Group provides a mock function with given fields: name
func (_m *MockGormDB) Group(name string) *gorm.DB {
	ret := _m.Called(name)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string) *gorm.DB); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Group_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Group'
type MockGormDB_Group_Call struct {
	*mock.Call
}

// Group is a helper method to define mock.On call
//   - name string
func (_e *MockGormDB_Expecter) Group(name interface{}) *MockGormDB_Group_Call {
	return &MockGormDB_Group_Call{Call: _e.mock.On("Group", name)}
}

func (_c *MockGormDB_Group_Call) Run(run func(name string)) *MockGormDB_Group_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGormDB_Group_Call) Return(tx *gorm.DB) *MockGormDB_Group_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Group_Call) RunAndReturn(run func(string) *gorm.DB) *MockGormDB_Group_Call {
	_c.Call.Return(run)
	return _c
}

// Having provides a mock function with given fields: query, args
func (_m *MockGormDB) Having(query interface{}, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Having_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Having'
type MockGormDB_Having_Call struct {
	*mock.Call
}

// Having is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Having(query interface{}, args ...interface{}) *MockGormDB_Having_Call {
	return &MockGormDB_Having_Call{Call: _e.mock.On("Having",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockGormDB_Having_Call) Run(run func(query interface{}, args ...interface{})) *MockGormDB_Having_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Having_Call) Return(tx *gorm.DB) *MockGormDB_Having_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Having_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Having_Call {
	_c.Call.Return(run)
	return _c
}

// InnerJoins provides a mock function with given fields: query, args
func (_m *MockGormDB) InnerJoins(query string, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *gorm.DB); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_InnerJoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InnerJoins'
type MockGormDB_InnerJoins_Call struct {
	*mock.Call
}

// InnerJoins is a helper method to define mock.On call
//   - query string
//   - args ...interface{}
func (_e *MockGormDB_Expecter) InnerJoins(query interface{}, args ...interface{}) *MockGormDB_InnerJoins_Call {
	return &MockGormDB_InnerJoins_Call{Call: _e.mock.On("InnerJoins",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockGormDB_InnerJoins_Call) Run(run func(query string, args ...interface{})) *MockGormDB_InnerJoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_InnerJoins_Call) Return(tx *gorm.DB) *MockGormDB_InnerJoins_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_InnerJoins_Call) RunAndReturn(run func(string, ...interface{}) *gorm.DB) *MockGormDB_InnerJoins_Call {
	_c.Call.Return(run)
	return _c
}

// InstanceGet provides a mock function with given fields: key
func (_m *MockGormDB) InstanceGet(key string) (interface{}, bool) {
	ret := _m.Called(key)

	var r0 interface{}
	var r1 bool
	if rf, ok := ret.Get(0).(func(string) (interface{}, bool)); ok {
		return rf(key)
	}
	if rf, ok := ret.Get(0).(func(string) interface{}); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MockGormDB_InstanceGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstanceGet'
type MockGormDB_InstanceGet_Call struct {
	*mock.Call
}

// InstanceGet is a helper method to define mock.On call
//   - key string
func (_e *MockGormDB_Expecter) InstanceGet(key interface{}) *MockGormDB_InstanceGet_Call {
	return &MockGormDB_InstanceGet_Call{Call: _e.mock.On("InstanceGet", key)}
}

func (_c *MockGormDB_InstanceGet_Call) Run(run func(key string)) *MockGormDB_InstanceGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGormDB_InstanceGet_Call) Return(_a0 interface{}, _a1 bool) *MockGormDB_InstanceGet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGormDB_InstanceGet_Call) RunAndReturn(run func(string) (interface{}, bool)) *MockGormDB_InstanceGet_Call {
	_c.Call.Return(run)
	return _c
}

// InstanceSet provides a mock function with given fields: key, value
func (_m *MockGormDB) InstanceSet(key string, value interface{}) *gorm.DB {
	ret := _m.Called(key, value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_InstanceSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InstanceSet'
type MockGormDB_InstanceSet_Call struct {
	*mock.Call
}

// InstanceSet is a helper method to define mock.On call
//   - key string
//   - value interface{}
func (_e *MockGormDB_Expecter) InstanceSet(key interface{}, value interface{}) *MockGormDB_InstanceSet_Call {
	return &MockGormDB_InstanceSet_Call{Call: _e.mock.On("InstanceSet", key, value)}
}

func (_c *MockGormDB_InstanceSet_Call) Run(run func(key string, value interface{})) *MockGormDB_InstanceSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_InstanceSet_Call) Return(_a0 *gorm.DB) *MockGormDB_InstanceSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_InstanceSet_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *MockGormDB_InstanceSet_Call {
	_c.Call.Return(run)
	return _c
}

// Joins provides a mock function with given fields: query, args
func (_m *MockGormDB) Joins(query string, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *gorm.DB); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Joins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Joins'
type MockGormDB_Joins_Call struct {
	*mock.Call
}

// Joins is a helper method to define mock.On call
//   - query string
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Joins(query interface{}, args ...interface{}) *MockGormDB_Joins_Call {
	return &MockGormDB_Joins_Call{Call: _e.mock.On("Joins",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockGormDB_Joins_Call) Run(run func(query string, args ...interface{})) *MockGormDB_Joins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Joins_Call) Return(tx *gorm.DB) *MockGormDB_Joins_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Joins_Call) RunAndReturn(run func(string, ...interface{}) *gorm.DB) *MockGormDB_Joins_Call {
	_c.Call.Return(run)
	return _c
}

// Last provides a mock function with given fields: dest, conds
func (_m *MockGormDB) Last(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Last_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Last'
type MockGormDB_Last_Call struct {
	*mock.Call
}

// Last is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MockGormDB_Expecter) Last(dest interface{}, conds ...interface{}) *MockGormDB_Last_Call {
	return &MockGormDB_Last_Call{Call: _e.mock.On("Last",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MockGormDB_Last_Call) Run(run func(dest interface{}, conds ...interface{})) *MockGormDB_Last_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Last_Call) Return(tx *gorm.DB) *MockGormDB_Last_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Last_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Last_Call {
	_c.Call.Return(run)
	return _c
}

// Limit provides a mock function with given fields: limit
func (_m *MockGormDB) Limit(limit int) *gorm.DB {
	ret := _m.Called(limit)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(int) *gorm.DB); ok {
		r0 = rf(limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Limit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Limit'
type MockGormDB_Limit_Call struct {
	*mock.Call
}

// Limit is a helper method to define mock.On call
//   - limit int
func (_e *MockGormDB_Expecter) Limit(limit interface{}) *MockGormDB_Limit_Call {
	return &MockGormDB_Limit_Call{Call: _e.mock.On("Limit", limit)}
}

func (_c *MockGormDB_Limit_Call) Run(run func(limit int)) *MockGormDB_Limit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *MockGormDB_Limit_Call) Return(tx *gorm.DB) *MockGormDB_Limit_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Limit_Call) RunAndReturn(run func(int) *gorm.DB) *MockGormDB_Limit_Call {
	_c.Call.Return(run)
	return _c
}

// Migrator provides a mock function with given fields:
func (_m *MockGormDB) Migrator() gorm.Migrator {
	ret := _m.Called()

	var r0 gorm.Migrator
	if rf, ok := ret.Get(0).(func() gorm.Migrator); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gorm.Migrator)
		}
	}

	return r0
}

// MockGormDB_Migrator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrator'
type MockGormDB_Migrator_Call struct {
	*mock.Call
}

// Migrator is a helper method to define mock.On call
func (_e *MockGormDB_Expecter) Migrator() *MockGormDB_Migrator_Call {
	return &MockGormDB_Migrator_Call{Call: _e.mock.On("Migrator")}
}

func (_c *MockGormDB_Migrator_Call) Run(run func()) *MockGormDB_Migrator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGormDB_Migrator_Call) Return(_a0 gorm.Migrator) *MockGormDB_Migrator_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Migrator_Call) RunAndReturn(run func() gorm.Migrator) *MockGormDB_Migrator_Call {
	_c.Call.Return(run)
	return _c
}

// Model provides a mock function with given fields: value
func (_m *MockGormDB) Model(value interface{}) *gorm.DB {
	ret := _m.Called(value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Model_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Model'
type MockGormDB_Model_Call struct {
	*mock.Call
}

// Model is a helper method to define mock.On call
//   - value interface{}
func (_e *MockGormDB_Expecter) Model(value interface{}) *MockGormDB_Model_Call {
	return &MockGormDB_Model_Call{Call: _e.mock.On("Model", value)}
}

func (_c *MockGormDB_Model_Call) Run(run func(value interface{})) *MockGormDB_Model_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Model_Call) Return(tx *gorm.DB) *MockGormDB_Model_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Model_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MockGormDB_Model_Call {
	_c.Call.Return(run)
	return _c
}

// Not provides a mock function with given fields: query, args
func (_m *MockGormDB) Not(query interface{}, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Not_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Not'
type MockGormDB_Not_Call struct {
	*mock.Call
}

// Not is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Not(query interface{}, args ...interface{}) *MockGormDB_Not_Call {
	return &MockGormDB_Not_Call{Call: _e.mock.On("Not",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockGormDB_Not_Call) Run(run func(query interface{}, args ...interface{})) *MockGormDB_Not_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Not_Call) Return(tx *gorm.DB) *MockGormDB_Not_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Not_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Not_Call {
	_c.Call.Return(run)
	return _c
}

// Offset provides a mock function with given fields: offset
func (_m *MockGormDB) Offset(offset int) *gorm.DB {
	ret := _m.Called(offset)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(int) *gorm.DB); ok {
		r0 = rf(offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Offset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Offset'
type MockGormDB_Offset_Call struct {
	*mock.Call
}

// Offset is a helper method to define mock.On call
//   - offset int
func (_e *MockGormDB_Expecter) Offset(offset interface{}) *MockGormDB_Offset_Call {
	return &MockGormDB_Offset_Call{Call: _e.mock.On("Offset", offset)}
}

func (_c *MockGormDB_Offset_Call) Run(run func(offset int)) *MockGormDB_Offset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *MockGormDB_Offset_Call) Return(tx *gorm.DB) *MockGormDB_Offset_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Offset_Call) RunAndReturn(run func(int) *gorm.DB) *MockGormDB_Offset_Call {
	_c.Call.Return(run)
	return _c
}

// Omit provides a mock function with given fields: columns
func (_m *MockGormDB) Omit(columns ...string) *gorm.DB {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...string) *gorm.DB); ok {
		r0 = rf(columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Omit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Omit'
type MockGormDB_Omit_Call struct {
	*mock.Call
}

// Omit is a helper method to define mock.On call
//   - columns ...string
func (_e *MockGormDB_Expecter) Omit(columns ...interface{}) *MockGormDB_Omit_Call {
	return &MockGormDB_Omit_Call{Call: _e.mock.On("Omit",
		append([]interface{}{}, columns...)...)}
}

func (_c *MockGormDB_Omit_Call) Run(run func(columns ...string)) *MockGormDB_Omit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Omit_Call) Return(tx *gorm.DB) *MockGormDB_Omit_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Omit_Call) RunAndReturn(run func(...string) *gorm.DB) *MockGormDB_Omit_Call {
	_c.Call.Return(run)
	return _c
}

// Or provides a mock function with given fields: query, args
func (_m *MockGormDB) Or(query interface{}, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Or_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Or'
type MockGormDB_Or_Call struct {
	*mock.Call
}

// Or is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Or(query interface{}, args ...interface{}) *MockGormDB_Or_Call {
	return &MockGormDB_Or_Call{Call: _e.mock.On("Or",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockGormDB_Or_Call) Run(run func(query interface{}, args ...interface{})) *MockGormDB_Or_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Or_Call) Return(tx *gorm.DB) *MockGormDB_Or_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Or_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Or_Call {
	_c.Call.Return(run)
	return _c
}

// Order provides a mock function with given fields: value
func (_m *MockGormDB) Order(value interface{}) *gorm.DB {
	ret := _m.Called(value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Order_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Order'
type MockGormDB_Order_Call struct {
	*mock.Call
}

// Order is a helper method to define mock.On call
//   - value interface{}
func (_e *MockGormDB_Expecter) Order(value interface{}) *MockGormDB_Order_Call {
	return &MockGormDB_Order_Call{Call: _e.mock.On("Order", value)}
}

func (_c *MockGormDB_Order_Call) Run(run func(value interface{})) *MockGormDB_Order_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Order_Call) Return(tx *gorm.DB) *MockGormDB_Order_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Order_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MockGormDB_Order_Call {
	_c.Call.Return(run)
	return _c
}

// Pluck provides a mock function with given fields: column, dest
func (_m *MockGormDB) Pluck(column string, dest interface{}) *gorm.DB {
	ret := _m.Called(column, dest)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Pluck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pluck'
type MockGormDB_Pluck_Call struct {
	*mock.Call
}

// Pluck is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *MockGormDB_Expecter) Pluck(column interface{}, dest interface{}) *MockGormDB_Pluck_Call {
	return &MockGormDB_Pluck_Call{Call: _e.mock.On("Pluck", column, dest)}
}

func (_c *MockGormDB_Pluck_Call) Run(run func(column string, dest interface{})) *MockGormDB_Pluck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Pluck_Call) Return(tx *gorm.DB) *MockGormDB_Pluck_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Pluck_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *MockGormDB_Pluck_Call {
	_c.Call.Return(run)
	return _c
}

// Preload provides a mock function with given fields: query, args
func (_m *MockGormDB) Preload(query string, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *gorm.DB); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Preload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Preload'
type MockGormDB_Preload_Call struct {
	*mock.Call
}

// Preload is a helper method to define mock.On call
//   - query string
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Preload(query interface{}, args ...interface{}) *MockGormDB_Preload_Call {
	return &MockGormDB_Preload_Call{Call: _e.mock.On("Preload",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockGormDB_Preload_Call) Run(run func(query string, args ...interface{})) *MockGormDB_Preload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Preload_Call) Return(tx *gorm.DB) *MockGormDB_Preload_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Preload_Call) RunAndReturn(run func(string, ...interface{}) *gorm.DB) *MockGormDB_Preload_Call {
	_c.Call.Return(run)
	return _c
}

// Raw provides a mock function with given fields: _a0, values
func (_m *MockGormDB) Raw(_a0 string, values ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *gorm.DB); ok {
		r0 = rf(_a0, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Raw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Raw'
type MockGormDB_Raw_Call struct {
	*mock.Call
}

// Raw is a helper method to define mock.On call
//   - _a0 string
//   - values ...interface{}
func (_e *MockGormDB_Expecter) Raw(_a0 interface{}, values ...interface{}) *MockGormDB_Raw_Call {
	return &MockGormDB_Raw_Call{Call: _e.mock.On("Raw",
		append([]interface{}{_a0}, values...)...)}
}

func (_c *MockGormDB_Raw_Call) Run(run func(_a0 string, values ...interface{})) *MockGormDB_Raw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Raw_Call) Return(tx *gorm.DB) *MockGormDB_Raw_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Raw_Call) RunAndReturn(run func(string, ...interface{}) *gorm.DB) *MockGormDB_Raw_Call {
	_c.Call.Return(run)
	return _c
}

// Rollback provides a mock function with given fields:
func (_m *MockGormDB) Rollback() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Rollback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rollback'
type MockGormDB_Rollback_Call struct {
	*mock.Call
}

// Rollback is a helper method to define mock.On call
func (_e *MockGormDB_Expecter) Rollback() *MockGormDB_Rollback_Call {
	return &MockGormDB_Rollback_Call{Call: _e.mock.On("Rollback")}
}

func (_c *MockGormDB_Rollback_Call) Run(run func()) *MockGormDB_Rollback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGormDB_Rollback_Call) Return(_a0 *gorm.DB) *MockGormDB_Rollback_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Rollback_Call) RunAndReturn(run func() *gorm.DB) *MockGormDB_Rollback_Call {
	_c.Call.Return(run)
	return _c
}

// RollbackTo provides a mock function with given fields: name
func (_m *MockGormDB) RollbackTo(name string) *gorm.DB {
	ret := _m.Called(name)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string) *gorm.DB); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_RollbackTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RollbackTo'
type MockGormDB_RollbackTo_Call struct {
	*mock.Call
}

// RollbackTo is a helper method to define mock.On call
//   - name string
func (_e *MockGormDB_Expecter) RollbackTo(name interface{}) *MockGormDB_RollbackTo_Call {
	return &MockGormDB_RollbackTo_Call{Call: _e.mock.On("RollbackTo", name)}
}

func (_c *MockGormDB_RollbackTo_Call) Run(run func(name string)) *MockGormDB_RollbackTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGormDB_RollbackTo_Call) Return(_a0 *gorm.DB) *MockGormDB_RollbackTo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_RollbackTo_Call) RunAndReturn(run func(string) *gorm.DB) *MockGormDB_RollbackTo_Call {
	_c.Call.Return(run)
	return _c
}

// Row provides a mock function with given fields:
func (_m *MockGormDB) Row() *sql.Row {
	ret := _m.Called()

	var r0 *sql.Row
	if rf, ok := ret.Get(0).(func() *sql.Row); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Row)
		}
	}

	return r0
}

// MockGormDB_Row_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Row'
type MockGormDB_Row_Call struct {
	*mock.Call
}

// Row is a helper method to define mock.On call
func (_e *MockGormDB_Expecter) Row() *MockGormDB_Row_Call {
	return &MockGormDB_Row_Call{Call: _e.mock.On("Row")}
}

func (_c *MockGormDB_Row_Call) Run(run func()) *MockGormDB_Row_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGormDB_Row_Call) Return(_a0 *sql.Row) *MockGormDB_Row_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Row_Call) RunAndReturn(run func() *sql.Row) *MockGormDB_Row_Call {
	_c.Call.Return(run)
	return _c
}

// Rows provides a mock function with given fields:
func (_m *MockGormDB) Rows() (*sql.Rows, error) {
	ret := _m.Called()

	var r0 *sql.Rows
	var r1 error
	if rf, ok := ret.Get(0).(func() (*sql.Rows, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *sql.Rows); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.Rows)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGormDB_Rows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rows'
type MockGormDB_Rows_Call struct {
	*mock.Call
}

// Rows is a helper method to define mock.On call
func (_e *MockGormDB_Expecter) Rows() *MockGormDB_Rows_Call {
	return &MockGormDB_Rows_Call{Call: _e.mock.On("Rows")}
}

func (_c *MockGormDB_Rows_Call) Run(run func()) *MockGormDB_Rows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGormDB_Rows_Call) Return(_a0 *sql.Rows, _a1 error) *MockGormDB_Rows_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGormDB_Rows_Call) RunAndReturn(run func() (*sql.Rows, error)) *MockGormDB_Rows_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: value
func (_m *MockGormDB) Save(value interface{}) *gorm.DB {
	ret := _m.Called(value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockGormDB_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - value interface{}
func (_e *MockGormDB_Expecter) Save(value interface{}) *MockGormDB_Save_Call {
	return &MockGormDB_Save_Call{Call: _e.mock.On("Save", value)}
}

func (_c *MockGormDB_Save_Call) Run(run func(value interface{})) *MockGormDB_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Save_Call) Return(tx *gorm.DB) *MockGormDB_Save_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Save_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MockGormDB_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SavePoint provides a mock function with given fields: name
func (_m *MockGormDB) SavePoint(name string) *gorm.DB {
	ret := _m.Called(name)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string) *gorm.DB); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_SavePoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SavePoint'
type MockGormDB_SavePoint_Call struct {
	*mock.Call
}

// SavePoint is a helper method to define mock.On call
//   - name string
func (_e *MockGormDB_Expecter) SavePoint(name interface{}) *MockGormDB_SavePoint_Call {
	return &MockGormDB_SavePoint_Call{Call: _e.mock.On("SavePoint", name)}
}

func (_c *MockGormDB_SavePoint_Call) Run(run func(name string)) *MockGormDB_SavePoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGormDB_SavePoint_Call) Return(_a0 *gorm.DB) *MockGormDB_SavePoint_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_SavePoint_Call) RunAndReturn(run func(string) *gorm.DB) *MockGormDB_SavePoint_Call {
	_c.Call.Return(run)
	return _c
}

// Scan provides a mock function with given fields: dest
func (_m *MockGormDB) Scan(dest interface{}) *gorm.DB {
	ret := _m.Called(dest)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Scan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scan'
type MockGormDB_Scan_Call struct {
	*mock.Call
}

// Scan is a helper method to define mock.On call
//   - dest interface{}
func (_e *MockGormDB_Expecter) Scan(dest interface{}) *MockGormDB_Scan_Call {
	return &MockGormDB_Scan_Call{Call: _e.mock.On("Scan", dest)}
}

func (_c *MockGormDB_Scan_Call) Run(run func(dest interface{})) *MockGormDB_Scan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Scan_Call) Return(tx *gorm.DB) *MockGormDB_Scan_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Scan_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MockGormDB_Scan_Call {
	_c.Call.Return(run)
	return _c
}

// ScanRows provides a mock function with given fields: rows, dest
func (_m *MockGormDB) ScanRows(rows *sql.Rows, dest interface{}) error {
	ret := _m.Called(rows, dest)

	var r0 error
	if rf, ok := ret.Get(0).(func(*sql.Rows, interface{}) error); ok {
		r0 = rf(rows, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGormDB_ScanRows_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScanRows'
type MockGormDB_ScanRows_Call struct {
	*mock.Call
}

// ScanRows is a helper method to define mock.On call
//   - rows *sql.Rows
//   - dest interface{}
func (_e *MockGormDB_Expecter) ScanRows(rows interface{}, dest interface{}) *MockGormDB_ScanRows_Call {
	return &MockGormDB_ScanRows_Call{Call: _e.mock.On("ScanRows", rows, dest)}
}

func (_c *MockGormDB_ScanRows_Call) Run(run func(rows *sql.Rows, dest interface{})) *MockGormDB_ScanRows_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*sql.Rows), args[1].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_ScanRows_Call) Return(_a0 error) *MockGormDB_ScanRows_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_ScanRows_Call) RunAndReturn(run func(*sql.Rows, interface{}) error) *MockGormDB_ScanRows_Call {
	_c.Call.Return(run)
	return _c
}

// Scopes provides a mock function with given fields: funcs
func (_m *MockGormDB) Scopes(funcs ...func(*gorm.DB) *gorm.DB) *gorm.DB {
	_va := make([]interface{}, len(funcs))
	for _i := range funcs {
		_va[_i] = funcs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(...func(*gorm.DB) *gorm.DB) *gorm.DB); ok {
		r0 = rf(funcs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Scopes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scopes'
type MockGormDB_Scopes_Call struct {
	*mock.Call
}

// Scopes is a helper method to define mock.On call
//   - funcs ...func(*gorm.DB) *gorm.DB
func (_e *MockGormDB_Expecter) Scopes(funcs ...interface{}) *MockGormDB_Scopes_Call {
	return &MockGormDB_Scopes_Call{Call: _e.mock.On("Scopes",
		append([]interface{}{}, funcs...)...)}
}

func (_c *MockGormDB_Scopes_Call) Run(run func(funcs ...func(*gorm.DB) *gorm.DB)) *MockGormDB_Scopes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*gorm.DB) *gorm.DB, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(func(*gorm.DB) *gorm.DB)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Scopes_Call) Return(tx *gorm.DB) *MockGormDB_Scopes_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Scopes_Call) RunAndReturn(run func(...func(*gorm.DB) *gorm.DB) *gorm.DB) *MockGormDB_Scopes_Call {
	_c.Call.Return(run)
	return _c
}

// Select provides a mock function with given fields: query, args
func (_m *MockGormDB) Select(query interface{}, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Select_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Select'
type MockGormDB_Select_Call struct {
	*mock.Call
}

// Select is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Select(query interface{}, args ...interface{}) *MockGormDB_Select_Call {
	return &MockGormDB_Select_Call{Call: _e.mock.On("Select",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockGormDB_Select_Call) Run(run func(query interface{}, args ...interface{})) *MockGormDB_Select_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Select_Call) Return(tx *gorm.DB) *MockGormDB_Select_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Select_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Select_Call {
	_c.Call.Return(run)
	return _c
}

// Session provides a mock function with given fields: config
func (_m *MockGormDB) Session(config *gorm.Session) *gorm.DB {
	ret := _m.Called(config)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(*gorm.Session) *gorm.DB); ok {
		r0 = rf(config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Session_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Session'
type MockGormDB_Session_Call struct {
	*mock.Call
}

// Session is a helper method to define mock.On call
//   - config *gorm.Session
func (_e *MockGormDB_Expecter) Session(config interface{}) *MockGormDB_Session_Call {
	return &MockGormDB_Session_Call{Call: _e.mock.On("Session", config)}
}

func (_c *MockGormDB_Session_Call) Run(run func(config *gorm.Session)) *MockGormDB_Session_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*gorm.Session))
	})
	return _c
}

func (_c *MockGormDB_Session_Call) Return(_a0 *gorm.DB) *MockGormDB_Session_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Session_Call) RunAndReturn(run func(*gorm.Session) *gorm.DB) *MockGormDB_Session_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function with given fields: key, value
func (_m *MockGormDB) Set(key string, value interface{}) *gorm.DB {
	ret := _m.Called(key, value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type MockGormDB_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - key string
//   - value interface{}
func (_e *MockGormDB_Expecter) Set(key interface{}, value interface{}) *MockGormDB_Set_Call {
	return &MockGormDB_Set_Call{Call: _e.mock.On("Set", key, value)}
}

func (_c *MockGormDB_Set_Call) Run(run func(key string, value interface{})) *MockGormDB_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Set_Call) Return(_a0 *gorm.DB) *MockGormDB_Set_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Set_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *MockGormDB_Set_Call {
	_c.Call.Return(run)
	return _c
}

// SetupJoinTable provides a mock function with given fields: model, field, joinTable
func (_m *MockGormDB) SetupJoinTable(model interface{}, field string, joinTable interface{}) error {
	ret := _m.Called(model, field, joinTable)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string, interface{}) error); ok {
		r0 = rf(model, field, joinTable)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGormDB_SetupJoinTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetupJoinTable'
type MockGormDB_SetupJoinTable_Call struct {
	*mock.Call
}

// SetupJoinTable is a helper method to define mock.On call
//   - model interface{}
//   - field string
//   - joinTable interface{}
func (_e *MockGormDB_Expecter) SetupJoinTable(model interface{}, field interface{}, joinTable interface{}) *MockGormDB_SetupJoinTable_Call {
	return &MockGormDB_SetupJoinTable_Call{Call: _e.mock.On("SetupJoinTable", model, field, joinTable)}
}

func (_c *MockGormDB_SetupJoinTable_Call) Run(run func(model interface{}, field string, joinTable interface{})) *MockGormDB_SetupJoinTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_SetupJoinTable_Call) Return(_a0 error) *MockGormDB_SetupJoinTable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_SetupJoinTable_Call) RunAndReturn(run func(interface{}, string, interface{}) error) *MockGormDB_SetupJoinTable_Call {
	_c.Call.Return(run)
	return _c
}

// Table provides a mock function with given fields: name, args
func (_m *MockGormDB) Table(name string, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *gorm.DB); ok {
		r0 = rf(name, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Table_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Table'
type MockGormDB_Table_Call struct {
	*mock.Call
}

// Table is a helper method to define mock.On call
//   - name string
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Table(name interface{}, args ...interface{}) *MockGormDB_Table_Call {
	return &MockGormDB_Table_Call{Call: _e.mock.On("Table",
		append([]interface{}{name}, args...)...)}
}

func (_c *MockGormDB_Table_Call) Run(run func(name string, args ...interface{})) *MockGormDB_Table_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Table_Call) Return(tx *gorm.DB) *MockGormDB_Table_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Table_Call) RunAndReturn(run func(string, ...interface{}) *gorm.DB) *MockGormDB_Table_Call {
	_c.Call.Return(run)
	return _c
}

// Take provides a mock function with given fields: dest, conds
func (_m *MockGormDB) Take(dest interface{}, conds ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(dest, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Take_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Take'
type MockGormDB_Take_Call struct {
	*mock.Call
}

// Take is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *MockGormDB_Expecter) Take(dest interface{}, conds ...interface{}) *MockGormDB_Take_Call {
	return &MockGormDB_Take_Call{Call: _e.mock.On("Take",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *MockGormDB_Take_Call) Run(run func(dest interface{}, conds ...interface{})) *MockGormDB_Take_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Take_Call) Return(tx *gorm.DB) *MockGormDB_Take_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Take_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Take_Call {
	_c.Call.Return(run)
	return _c
}

// ToSQL provides a mock function with given fields: queryFn
func (_m *MockGormDB) ToSQL(queryFn func(*gorm.DB) *gorm.DB) string {
	ret := _m.Called(queryFn)

	var r0 string
	if rf, ok := ret.Get(0).(func(func(*gorm.DB) *gorm.DB) string); ok {
		r0 = rf(queryFn)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockGormDB_ToSQL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToSQL'
type MockGormDB_ToSQL_Call struct {
	*mock.Call
}

// ToSQL is a helper method to define mock.On call
//   - queryFn func(*gorm.DB) *gorm.DB
func (_e *MockGormDB_Expecter) ToSQL(queryFn interface{}) *MockGormDB_ToSQL_Call {
	return &MockGormDB_ToSQL_Call{Call: _e.mock.On("ToSQL", queryFn)}
}

func (_c *MockGormDB_ToSQL_Call) Run(run func(queryFn func(*gorm.DB) *gorm.DB)) *MockGormDB_ToSQL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(*gorm.DB) *gorm.DB))
	})
	return _c
}

func (_c *MockGormDB_ToSQL_Call) Return(_a0 string) *MockGormDB_ToSQL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_ToSQL_Call) RunAndReturn(run func(func(*gorm.DB) *gorm.DB) string) *MockGormDB_ToSQL_Call {
	_c.Call.Return(run)
	return _c
}

// Transaction provides a mock function with given fields: fc, opts
func (_m *MockGormDB) Transaction(fc func(*gorm.DB) error, opts ...*sql.TxOptions) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fc)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*gorm.DB) error, ...*sql.TxOptions) error); ok {
		r0 = rf(fc, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGormDB_Transaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transaction'
type MockGormDB_Transaction_Call struct {
	*mock.Call
}

// Transaction is a helper method to define mock.On call
//   - fc func(*gorm.DB) error
//   - opts ...*sql.TxOptions
func (_e *MockGormDB_Expecter) Transaction(fc interface{}, opts ...interface{}) *MockGormDB_Transaction_Call {
	return &MockGormDB_Transaction_Call{Call: _e.mock.On("Transaction",
		append([]interface{}{fc}, opts...)...)}
}

func (_c *MockGormDB_Transaction_Call) Run(run func(fc func(*gorm.DB) error, opts ...*sql.TxOptions)) *MockGormDB_Transaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*sql.TxOptions, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(*sql.TxOptions)
			}
		}
		run(args[0].(func(*gorm.DB) error), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Transaction_Call) Return(err error) *MockGormDB_Transaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockGormDB_Transaction_Call) RunAndReturn(run func(func(*gorm.DB) error, ...*sql.TxOptions) error) *MockGormDB_Transaction_Call {
	_c.Call.Return(run)
	return _c
}

// Unscoped provides a mock function with given fields:
func (_m *MockGormDB) Unscoped() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Unscoped_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unscoped'
type MockGormDB_Unscoped_Call struct {
	*mock.Call
}

// Unscoped is a helper method to define mock.On call
func (_e *MockGormDB_Expecter) Unscoped() *MockGormDB_Unscoped_Call {
	return &MockGormDB_Unscoped_Call{Call: _e.mock.On("Unscoped")}
}

func (_c *MockGormDB_Unscoped_Call) Run(run func()) *MockGormDB_Unscoped_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGormDB_Unscoped_Call) Return(tx *gorm.DB) *MockGormDB_Unscoped_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Unscoped_Call) RunAndReturn(run func() *gorm.DB) *MockGormDB_Unscoped_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: column, value
func (_m *MockGormDB) Update(column string, value interface{}) *gorm.DB {
	ret := _m.Called(column, value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockGormDB_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *MockGormDB_Expecter) Update(column interface{}, value interface{}) *MockGormDB_Update_Call {
	return &MockGormDB_Update_Call{Call: _e.mock.On("Update", column, value)}
}

func (_c *MockGormDB_Update_Call) Run(run func(column string, value interface{})) *MockGormDB_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Update_Call) Return(tx *gorm.DB) *MockGormDB_Update_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Update_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *MockGormDB_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateColumn provides a mock function with given fields: column, value
func (_m *MockGormDB) UpdateColumn(column string, value interface{}) *gorm.DB {
	ret := _m.Called(column, value)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(string, interface{}) *gorm.DB); ok {
		r0 = rf(column, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_UpdateColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateColumn'
type MockGormDB_UpdateColumn_Call struct {
	*mock.Call
}

// UpdateColumn is a helper method to define mock.On call
//   - column string
//   - value interface{}
func (_e *MockGormDB_Expecter) UpdateColumn(column interface{}, value interface{}) *MockGormDB_UpdateColumn_Call {
	return &MockGormDB_UpdateColumn_Call{Call: _e.mock.On("UpdateColumn", column, value)}
}

func (_c *MockGormDB_UpdateColumn_Call) Run(run func(column string, value interface{})) *MockGormDB_UpdateColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_UpdateColumn_Call) Return(tx *gorm.DB) *MockGormDB_UpdateColumn_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_UpdateColumn_Call) RunAndReturn(run func(string, interface{}) *gorm.DB) *MockGormDB_UpdateColumn_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateColumns provides a mock function with given fields: values
func (_m *MockGormDB) UpdateColumns(values interface{}) *gorm.DB {
	ret := _m.Called(values)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_UpdateColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateColumns'
type MockGormDB_UpdateColumns_Call struct {
	*mock.Call
}

// UpdateColumns is a helper method to define mock.On call
//   - values interface{}
func (_e *MockGormDB_Expecter) UpdateColumns(values interface{}) *MockGormDB_UpdateColumns_Call {
	return &MockGormDB_UpdateColumns_Call{Call: _e.mock.On("UpdateColumns", values)}
}

func (_c *MockGormDB_UpdateColumns_Call) Run(run func(values interface{})) *MockGormDB_UpdateColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_UpdateColumns_Call) Return(tx *gorm.DB) *MockGormDB_UpdateColumns_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_UpdateColumns_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MockGormDB_UpdateColumns_Call {
	_c.Call.Return(run)
	return _c
}

// Updates provides a mock function with given fields: values
func (_m *MockGormDB) Updates(values interface{}) *gorm.DB {
	ret := _m.Called(values)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}) *gorm.DB); ok {
		r0 = rf(values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Updates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Updates'
type MockGormDB_Updates_Call struct {
	*mock.Call
}

// Updates is a helper method to define mock.On call
//   - values interface{}
func (_e *MockGormDB_Expecter) Updates(values interface{}) *MockGormDB_Updates_Call {
	return &MockGormDB_Updates_Call{Call: _e.mock.On("Updates", values)}
}

func (_c *MockGormDB_Updates_Call) Run(run func(values interface{})) *MockGormDB_Updates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *MockGormDB_Updates_Call) Return(tx *gorm.DB) *MockGormDB_Updates_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Updates_Call) RunAndReturn(run func(interface{}) *gorm.DB) *MockGormDB_Updates_Call {
	_c.Call.Return(run)
	return _c
}

// Use provides a mock function with given fields: plugin
func (_m *MockGormDB) Use(plugin gorm.Plugin) error {
	ret := _m.Called(plugin)

	var r0 error
	if rf, ok := ret.Get(0).(func(gorm.Plugin) error); ok {
		r0 = rf(plugin)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGormDB_Use_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Use'
type MockGormDB_Use_Call struct {
	*mock.Call
}

// Use is a helper method to define mock.On call
//   - plugin gorm.Plugin
func (_e *MockGormDB_Expecter) Use(plugin interface{}) *MockGormDB_Use_Call {
	return &MockGormDB_Use_Call{Call: _e.mock.On("Use", plugin)}
}

func (_c *MockGormDB_Use_Call) Run(run func(plugin gorm.Plugin)) *MockGormDB_Use_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(gorm.Plugin))
	})
	return _c
}

func (_c *MockGormDB_Use_Call) Return(_a0 error) *MockGormDB_Use_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_Use_Call) RunAndReturn(run func(gorm.Plugin) error) *MockGormDB_Use_Call {
	_c.Call.Return(run)
	return _c
}

// Where provides a mock function with given fields: query, args
func (_m *MockGormDB) Where(query interface{}, args ...interface{}) *gorm.DB {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *gorm.DB); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_Where_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Where'
type MockGormDB_Where_Call struct {
	*mock.Call
}

// Where is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *MockGormDB_Expecter) Where(query interface{}, args ...interface{}) *MockGormDB_Where_Call {
	return &MockGormDB_Where_Call{Call: _e.mock.On("Where",
		append([]interface{}{query}, args...)...)}
}

func (_c *MockGormDB_Where_Call) Run(run func(query interface{}, args ...interface{})) *MockGormDB_Where_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *MockGormDB_Where_Call) Return(tx *gorm.DB) *MockGormDB_Where_Call {
	_c.Call.Return(tx)
	return _c
}

func (_c *MockGormDB_Where_Call) RunAndReturn(run func(interface{}, ...interface{}) *gorm.DB) *MockGormDB_Where_Call {
	_c.Call.Return(run)
	return _c
}

// WithContext provides a mock function with given fields: ctx
func (_m *MockGormDB) WithContext(ctx context.Context) *gorm.DB {
	ret := _m.Called(ctx)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(context.Context) *gorm.DB); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// MockGormDB_WithContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithContext'
type MockGormDB_WithContext_Call struct {
	*mock.Call
}

// WithContext is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockGormDB_Expecter) WithContext(ctx interface{}) *MockGormDB_WithContext_Call {
	return &MockGormDB_WithContext_Call{Call: _e.mock.On("WithContext", ctx)}
}

func (_c *MockGormDB_WithContext_Call) Run(run func(ctx context.Context)) *MockGormDB_WithContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockGormDB_WithContext_Call) Return(_a0 *gorm.DB) *MockGormDB_WithContext_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGormDB_WithContext_Call) RunAndReturn(run func(context.Context) *gorm.DB) *MockGormDB_WithContext_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGormDB creates a new instance of MockGormDB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGormDB(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGormDB {
	mock := &MockGormDB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
